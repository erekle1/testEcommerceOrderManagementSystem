---
globs: *.php
---

# Laravel Coding Conventions & Best Practices

## Code Style & Standards

### General Standards
- **Redundancy Checks**: Eliminate redundant code blocks and logic duplications
- **Completeness Checks**: Verify all code and features are fully implemented and tested
- **Code Formatting**: Use Prettier package for consistent formatting
- **Indentation**: Use 4 spaces for indentation across all files
- **Line Length**: Limit lines to 120 characters maximum
- **PSR Standards**: Follow PSR-12 coding standards with Laravel Pint

### Naming Conventions
- **Controllers**: PascalCase with Controller suffix (e.g., UserController)
- **Models**: Singular PascalCase (e.g., User, Order)
- **Factories**: PascalCase with Factory suffix (e.g., UserFactory)
- **Migrations**: PascalCase matching model name (e.g., CreateUserTable)
- **Methods**: camelCase with descriptive names (e.g., getActiveUsers, calculateTotalAmount)
- **Variables**: camelCase with meaningful names (e.g., $userEmail, $totalAmount)
- **Enums**: Use Enums for constant variables to avoid mistakes

### Enum Usage
```php
<?php

namespace App\Enums;

enum UserTypeEnum: string
{
    case ADMIN = 'admin';
    case RESTAURANT_OWNER = 'restaurant_owner';
    case CUSTOMER = 'customer';
    
    // Accessing: UserTypeEnum::ADMIN->value
}
```

### Class Structure
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\SoftDeletes;

/**
 * Order model representing customer orders
 */
class Order extends Model
{
    use SoftDeletes;
    
    protected $fillable = [
        'customer_id',
        'total_amount',
        'status',
        'shipping_address',
        'billing_address',
    ];

    protected $casts = [
        'total_amount' => 'decimal:2',
        'created_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    // Relationships
    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function orderItems(): HasMany
    {
        return $this->hasMany(OrderItem::class);
    }

    // Accessors & Mutators
    public function getFormattedTotalAttribute(): string
    {
        return '$' . number_format($this->total_amount, 2);
    }

    // Scopes
    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    // Business Logic Methods
    public function calculateTotal(): float
    {
        return $this->orderItems->sum('subtotal');
    }
}
```

## Controllers

### Controller Standards
- **Thin Controllers**: Keep controllers thin by delegating logic to service classes
- **Resource Controllers**: Use resource controllers for CRUD operations
- **Method Order**: Constructor, middleware, public methods, private methods
- **Service Injection**: Inject service classes into controllers
- **Form Requests**: Use form requests for validation on every POST/PUT API

### Controller Example
```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\StoreOrderRequest;
use App\Http\Requests\UpdateOrderRequest;
use App\Models\Order;
use App\Services\OrderService;
use Spatie\LaravelData\Data;

class OrderController extends Controller
{
    public function __construct(
        private OrderService $orderService
    ) {}

    /**
     * Display a listing of orders
     */
    public function index()
    {
        $orders = Order::with(['customer', 'orderItems'])
            ->latest()
            ->paginate(15);

        return view('orders.index', compact('orders'));
    }

    /**
     * Store a newly created order
     */
    public function store(StoreOrderRequest $request)
    {
        $data = CreateOrderData::from($request->validated());
        $result = $this->orderService->createOrder($data);
        
        return $this->successfulResponse($result, __('Order created successfully'));
    }
}
```

## Models & Eloquent

### Model Standards
- **Naming**: Use singular, PascalCase names for models
- **Fillable Properties**: Define `$fillable` properties instead of `$guarded`
- **Soft Deletes**: Add SoftDeletes trait to prevent permanent deletes
- **Relationships**: Define relationships using appropriate methods
- **Type Casting**: Use proper type casting with `$casts`
- **Scopes**: Add scopes for common query patterns

### Model Example
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Order extends Model
{
    use SoftDeletes;
    
    protected $fillable = [
        'customer_id',
        'total_amount',
        'status',
        'shipping_address',
        'billing_address',
    ];

    protected $casts = [
        'total_amount' => 'decimal:2',
        'created_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    // Relationships
    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function orderItems(): HasMany
    {
        return $this->hasMany(OrderItem::class);
    }

    // Scopes
    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }
}
```

## Services & Business Logic

### Service Standards
- **Encapsulation**: Encapsulate business logic in service classes
- **Single Responsibility**: Keep services focused on single responsibilities
- **Dependency Injection**: Use dependency injection
- **Return Values**: Return meaningful results
- **Data Objects**: Use Spatie Data package for structured data handling

### Service Example
```php
<?php

namespace App\Services;

use App\Models\Order;
use App\Models\OrderItem;
use App\Data\CreateOrderData;
use Illuminate\Support\Facades\DB;

class OrderService
{
    /**
     * Create a new order with items
     */
    public function createOrder(CreateOrderData $data): Order
    {
        return DB::transaction(function () use ($data) {
            $order = Order::create([
                'customer_id' => $data->customerId,
                'status' => 'pending',
                'shipping_address' => $data->shippingAddress,
                'billing_address' => $data->billingAddress,
            ]);

            foreach ($data->items as $item) {
                $order->orderItems()->create([
                    'product_id' => $item->productId,
                    'quantity' => $item->quantity,
                    'unit_price' => $item->price,
                    'subtotal' => $item->quantity * $item->price,
                ]);
            }

            $order->update(['total_amount' => $order->calculateTotal()]);

            return $order;
        });
    }
}
```

## Validation & Form Requests

### Validation Standards
- **Form Requests**: Use Form Request classes for validating incoming data for every POST/PUT API
- **Spatie Data Package**: Use Spatie Data package to convert FormRequest data into listed attributes
- **Custom Validation Rules**: Create custom validation rules where needed
- **Client-Side Validation**: Manage validation at the client-side before sending data

### Form Request Example
```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class StoreOrderRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'customer_id' => 'required|exists:customers,id',
            'items' => 'required|array|min:1',
            'items.*.product_id' => 'required|exists:products,id',
            'items.*.quantity' => 'required|integer|min:1',
            'items.*.price' => 'required|numeric|min:0',
            'shipping_address' => 'required|string|max:255',
            'billing_address' => 'required|string|max:255',
        ];
    }

    public function messages(): array
    {
        return [
            'items.required' => 'At least one item is required.',
            'items.*.quantity.min' => 'Quantity must be at least 1.',
        ];
    }
}
```

### Spatie Data Example
```php
<?php

namespace App\Data;

use Spatie\LaravelData\Data;

class CreateOrderData extends Data
{
    public function __construct(
        public int $customerId,
        public array $items,
        public string $shippingAddress,
        public string $billingAddress,
    ) {}
}
```

### Custom Validation Rule Example
```php
<?php

namespace App\Rules;

use Illuminate\Contracts\Validation\Rule;

class PhoneNumber implements Rule
{
    public function passes($attribute, $value, $arguments = [])
    {
        $pattern = '/^\d{3}-\d{3}-\d{4}$/';
        return preg_match($pattern, $value);
    }

    public function message($attribute, $parameters)
    {
        return 'The :attribute must be a valid phone number';
    }
}
```

## Error Handling & Logging

### Error Handling Standards
- **Try-Catch Blocks**: Use try-catch blocks to handle exceptions gracefully and log errors
- **Custom Exceptions**: Create custom exceptions for domain-specific errors
- **Logging**: Log each request to the controller and create activity logs for each endpoint/action
- **Error Logging**: Log errors with the method name

### Error Handling Example
```php
try {
    $order = $this->orderService->createOrder($data);
} catch (InsufficientStockException $e) {
    Log::error([
        'message' => $e->getMessage(),
        'line' => $e->getLine(),
        'trace' => $e->getTrace(),
        'timestamp' => now(),
        'method' => __METHOD__,
    ]);

    return back()
        ->withErrors(['stock' => 'Insufficient stock for selected items.'])
        ->withInput();
} catch (Exception $e) {
    Log::error([
        'message' => $e->getMessage(),
        'line' => $e->getLine(),
        'trace' => $e->getTrace(),
        'timestamp' => now(),
        'method' => __METHOD__,
    ]);

    return back()
        ->withErrors(['general' => 'An error occurred while creating the order.'])
        ->withInput();
}
```

### Custom Exception Example
```php
<?php

namespace App\Exceptions;

use Exception;

class InsufficientStockException extends Exception
{
    public function __construct(string $productName, int $requested, int $available)
    {
        parent::__construct(
            "Insufficient stock for {$productName}. Requested: {$requested}, Available: {$available}"
        );
    }
}
```

## Documentation Standards

### PHPDoc Requirements
- Use PHPDoc for methods and classes
- Include parameter descriptions and return types
- Document complex business logic

### PHPDoc Example
```php
/**
 * Get the user's full name.
 * 
 * @param bool $includeTitle Whether to include the user's title
 * @return string The user's full name
 */
public function getFullName(bool $includeTitle = false): string
{
    $name = $this->firstName . ' ' . $this->lastName;
    
    if ($includeTitle && $this->title) {
        $name = $this->title . ' ' . $name;
    }
    
    return $name;
}
```

## Route Standards

### Route Conventions
- **RESTful Routes**: Use RESTful routes for resource controllers
- **Resource Routes**: Use Route::resource methods for all resource routes
- **Kebab Casing**: Use kebab casing for URLs (e.g., /user-profile, /order-items)
- **Named Routes**: Use the name method for all URLs
- **Main ID Route**: Use /orders/{id} instead of orders?id={id}

### Route Examples
```php
// Resource routes
Route::resource('users', UserController::class);
Route::resource('orders', OrderController::class);

// Named routes
Route::get('/users/{id}', [UserController::class, 'show'])->name('user.show');
Route::get('/order-items', [OrderItemController::class, 'index'])->name('order-items.index');
```

## Query Optimization

### Database Optimization
- **Eager Loading**: Follow eager loading in queries to prevent N+1 problems
- **Business Logic Separation**: Separate business logic from the controller
- **Client-Side Validation**: Manage validation at the client-side before sending data

### Query Examples
```php
// Eager loading to prevent N+1 queries
$users = User::with('orders')->get();

// Use traits for methods instead of applying queries directly in controllers
trait OrderQueries
{
    public function getActiveOrders()
    {
        return $this->orders()->where('status', 'active')->get();
    }
}
```