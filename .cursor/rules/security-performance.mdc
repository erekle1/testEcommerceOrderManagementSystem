---
globs: *.php,*.js,*.blade.php
---

# Security & Performance Guidelines

## Security Best Practices

### Authentication & Authorization
- **Laravel Authentication**: Use Laravel's built-in authentication system
- **Authorization Policies**: Implement proper authorization policies
- **Middleware Protection**: Use middleware for route protection
- **Input Validation**: Validate all user inputs
- **CSRF Protection**: Use CSRF protection for forms
- **Data Sanitization**: Sanitize data before database operations

### Additional Security Measures
- **Login Attempt Limits**: Implement login attempt limits and account suspension
- **Input Sanitization**: Sanitize and validate all input data
- **XSS Protection**: Use Blade's {{ }} to escape output
- **CSRF Protection**: Ensure all forms include CSRF tokens

### Security Implementation
```php
// CSRF Protection in forms
<form method="POST" action="{{ route('user.store') }}">
    @csrf
    <input type="text" name="name" value="{{ old('name') }}">
    <button type="submit">Submit</button>
</form>

// Mass assignment protection
protected $fillable = ['name', 'email']; // Allow only specific fields
protected $guarded = []; // Guard all fields except specified

// Encryption for sensitive data
use Illuminate\Support\Facades\Crypt;

$encrypted = Crypt::encrypt($sensitiveData);
$decrypted = Crypt::decrypt($encrypted);
```

### Input Validation & SQL Injection Prevention
```php
// Always validate user input
public function store(Request $request)
{
    $validated = $request->validate([
        'email' => 'required|email|unique:users',
        'password' => 'required|min:8|confirmed',
    ]);
    
    // Use validated data only
    User::create($validated);
}

// Use Eloquent ORM (automatically prevents SQL injection)
$users = User::where('email', $email)->get();

// Use parameterized queries for raw SQL
DB::select('SELECT * FROM users WHERE email = ?', [$email]);
```

## Performance Optimization

### Database Performance
```php
// Use eager loading to prevent N+1 queries
$orders = Order::with(['customer', 'orderItems.product'])->get();

// Use select specific columns
$orders = Order::select(['id', 'customer_id', 'total_amount'])
    ->with(['customer:id,first_name,last_name'])
    ->get();

// Use database indexes
Schema::table('orders', function (Blueprint $table) {
    $table->index(['customer_id', 'status']);
    $table->index('created_at');
});
```

### Query Optimization
```php
// Use chunking for large datasets
Order::chunk(100, function ($orders) {
    foreach ($orders as $order) {
        // Process each order
    }
});

// Use pagination for large result sets
$orders = Order::paginate(15);

// Use lazy loading for relationships
$orders = Order::lazy();

// Use cursor for large datasets
foreach (Order::cursor() as $order) {
    // Process each order without loading all into memory
}

// Use chunkById for ordered processing
Order::chunkById(100, function ($orders) {
    foreach ($orders as $order) {
        // Process orders in batches
    }
});
```

### Caching Strategies
```php
// Use Laravel's caching system
use Illuminate\Support\Facades\Cache;

// Cache expensive operations
$products = Cache::remember('products', 3600, function () {
    return Product::with('category')->get();
});

// Cache database queries
$orders = Cache::remember("orders.{$customerId}", 300, function () use ($customerId) {
    return Order::where('customer_id', $customerId)->get();
});
```

## Frontend Performance

### Asset Optimization
```javascript
// Use Vite's built-in optimization
// Code splitting for large applications
const OrderComponent = lazy(() => import('./OrderComponent'));

// Optimize images
<img src="image.webp" alt="Product" loading="lazy" />
```

### CSS Optimization
```css
/* Use Tailwind's JIT compilation */
/* Purge unused CSS in production */
/* Minimize custom CSS in favor of utilities */
```

## Memory Management

### PHP Memory Optimization
```php
// Use generators for large datasets
function getLargeDataset()
{
    foreach (range(1, 1000000) as $i) {
        yield $i;
    }
}

// Unset large variables when done
$largeArray = getLargeData();
processData($largeArray);
unset($largeArray);
```

## Error Handling & Logging

### Proper Error Handling
```php
try {
    $order = $this->orderService->createOrder($data);
} catch (InsufficientStockException $e) {
    Log::error([
        'message' => $e->getMessage(),
        'line' => $e->getLine(),
        'trace' => $e->getTrace(),
        'timestamp' => now(),
        'method' => __METHOD__,
    ]);

    return back()
        ->withErrors(['stock' => 'Insufficient stock for selected items.'])
        ->withInput();
} catch (Exception $e) {
    Log::error([
        'message' => $e->getMessage(),
        'line' => $e->getLine(),
        'trace' => $e->getTrace(),
        'timestamp' => now(),
        'method' => __METHOD__,
    ]);

    return back()
        ->withErrors(['general' => 'An error occurred while creating the order.'])
        ->withInput();
}
```

### Logging Best Practices
```php
use Illuminate\Support\Facades\Log;

// Use appropriate log levels
Log::emergency('System is unusable');
Log::alert('Action must be taken immediately');
Log::critical('Critical conditions');
Log::error('Error conditions');
Log::warning('Warning conditions');
Log::notice('Normal but significant conditions');
Log::info('Informational messages');
Log::debug('Debug-level messages');

// Include context in logs
Log::info('Order created', [
    'order_id' => $order->id,
    'customer_id' => $order->customer_id,
    'total_amount' => $order->total_amount,
]);
```

## Rate Limiting & Throttling

### API Rate Limiting
```php
// In routes/api.php
Route::middleware('throttle:60,1')->group(function () {
    Route::get('/orders', [OrderController::class, 'index']);
    Route::post('/orders', [OrderController::class, 'store']);
});

// Custom rate limiting
Route::middleware('throttle:10,1')->group(function () {
    Route::post('/orders/bulk', [OrderController::class, 'bulkCreate']);
});
```

## Monitoring & Debugging

### Performance Monitoring
```php
// Use Laravel Telescope for debugging (development only)
// Monitor slow queries
DB::listen(function ($query) {
    if ($query->time > 1000) { // Log queries taking more than 1 second
        Log::warning('Slow query detected', [
            'sql' => $query->sql,
            'bindings' => $query->bindings,
            'time' => $query->time,
        ]);
    }
});
```

### Health Checks
```php
// Create health check endpoint
Route::get('/health', function () {
    return response()->json([
        'status' => 'ok',
        'timestamp' => now(),
        'database' => DB::connection()->getPdo() ? 'connected' : 'disconnected',
        'cache' => Cache::store()->getStore() ? 'connected' : 'disconnected',
    ]);
});
```